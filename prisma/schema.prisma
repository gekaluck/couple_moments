// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                       String             @id @default(cuid())
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt

  email                    String             @unique
  passwordHash             String
  name                     String?

  emailRemindersEnabled    Boolean            @default(true)

  memberships              Membership[]
  eventsCreated            Event[]            @relation("EventsCreatedBy")
  ideasCreated             Idea[]             @relation("IdeasCreatedBy")
  photos                   Photo[]
  reactions                Reaction[]
  ratings                  Rating[]
  availabilityBlocks       AvailabilityBlock[]
  notes                    Note[]
  changeLogs               ChangeLogEntry[]
  notifications            Notification[]
  sessions                 Session[]
  externalAccounts         ExternalAccount[]
  externalAvailabilityBlocks ExternalAvailabilityBlock[]
}

model Session {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  expiresAt DateTime

  userId    String
  token     String   @unique

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([expiresAt])
}

model CoupleSpace {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  name        String?
  inviteCode  String        @unique

  memberships Membership[]
  events      Event[]
  ideas       Idea[]
  availabilityBlocks AvailabilityBlock[]
  notes       Note[]
  changeLogs  ChangeLogEntry[]
}

model Membership {
  id            String       @id @default(cuid())
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  userId        String
  coupleSpaceId String
  role          String       @default("member")

  user          User         @relation(fields: [userId], references: [id])
  coupleSpace   CoupleSpace  @relation(fields: [coupleSpaceId], references: [id])

  @@unique([userId, coupleSpaceId])
}

model Event {
  id              String        @id @default(cuid())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  coupleSpaceId   String
  createdByUserId String
  title           String
  description     String?
  type            EventType
  dateTimeStart   DateTime
  dateTimeEnd     DateTime?
  timeIsSet       Boolean       @default(true)
  tags            String        @default("[]")
  originIdeaId    String?       @unique
  placeId         String?
  placeName       String?
  placeAddress    String?
  placeLat        Float?
  placeLng        Float?
  placeUrl        String?
  placeWebsite    String?
  placeOpeningHours Json?
  placePhotoUrls  Json?

  coupleSpace     CoupleSpace   @relation(fields: [coupleSpaceId], references: [id])
  createdBy       User          @relation("EventsCreatedBy", fields: [createdByUserId], references: [id])

  photos          Photo[]
  ratings         Rating[]
  originIdea      Idea?         @relation("IdeaConvertedEvent", fields: [originIdeaId], references: [id])
  notifications   Notification[]
  externalEventLink ExternalEventLink?

  @@index([coupleSpaceId, dateTimeStart])
  @@index([dateTimeStart])
}

enum EventType {
  PLANNED
  MEMORY
}

model AvailabilityBlock {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  coupleSpaceId   String
  createdByUserId String
  title           String
  note            String?
  startAt         DateTime
  endAt           DateTime

  coupleSpace     CoupleSpace @relation(fields: [coupleSpaceId], references: [id])
  createdBy       User        @relation(fields: [createdByUserId], references: [id])
}

model Photo {
  id               String    @id @default(cuid())
  createdAt        DateTime  @default(now())

  eventId          String
  uploadedByUserId String
  storageUrl       String

  event            Event     @relation(fields: [eventId], references: [id])
  uploadedBy       User      @relation(fields: [uploadedByUserId], references: [id])
}

model Idea {
  id              String       @id @default(cuid())
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  coupleSpaceId   String
  createdByUserId String
  title           String
  description     String?
  tags            String        @default("[]")
  status          IdeaStatus   @default(NEW)
  convertedToEventId String?    @unique
  placeId         String?
  placeName       String?
  placeAddress    String?
  placeLat        Float?
  placeLng        Float?
  placeUrl        String?
  placeWebsite    String?
  placeOpeningHours Json?
  placePhotoUrls  Json?

  coupleSpace     CoupleSpace  @relation(fields: [coupleSpaceId], references: [id])
  createdBy       User         @relation("IdeasCreatedBy", fields: [createdByUserId], references: [id])
  convertedToEvent Event?       @relation("IdeaConvertedEvent")

  @@index([coupleSpaceId, status])
}

enum IdeaStatus {
  NEW
  PLANNED
  DONE
}

model Note {
  id             String        @id @default(cuid())
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  coupleSpaceId  String
  authorUserId   String
  body           String
  kind           NoteKind
  parentType     NoteParentType?
  parentId       String?
  replyToNoteId  String?

  coupleSpace    CoupleSpace   @relation(fields: [coupleSpaceId], references: [id])
  author         User          @relation(fields: [authorUserId], references: [id])
  replyTo        Note?         @relation("NoteReplies", fields: [replyToNoteId], references: [id])
  replies        Note[]        @relation("NoteReplies")

  @@index([coupleSpaceId, kind])
}

model Reaction {
  id         String        @id @default(cuid())
  createdAt  DateTime      @default(now())

  userId     String
  targetType ReactionTargetType
  targetId   String
  emoji      String

  user       User          @relation(fields: [userId], references: [id])
}

model Rating {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  value     Int
  userId    String
  eventId   String

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([eventId])
}

model ChangeLogEntry {
  id            String      @id @default(cuid())
  createdAt     DateTime    @default(now())

  coupleSpaceId String?
  entityType    EntityType
  entityId      String
  userId        String
  changeType    ChangeType
  summary       String

  coupleSpace   CoupleSpace? @relation(fields: [coupleSpaceId], references: [id])
  user          User         @relation(fields: [userId], references: [id])

  @@index([coupleSpaceId, createdAt])
}

enum EntityType {
  EVENT
  IDEA
  NOTE
}

enum ChangeType {
  CREATE
  UPDATE
  DELETE
}

/// Planned feature model. Kept intentionally for future reminder/notification flows.
model Notification {
  id          String             @id @default(cuid())
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  userId      String
  eventId     String
  type        NotificationType
  scheduledAt DateTime
  sentAt      DateTime?

  user        User               @relation(fields: [userId], references: [id])
  event       Event              @relation(fields: [eventId], references: [id])
}

enum NotificationType {
  REMINDER_UPCOMING_EVENT
}

enum NoteKind {
  MANUAL
  EVENT_COMMENT
  IDEA_COMMENT
}

enum NoteParentType {
  EVENT
  IDEA
}

enum ReactionTargetType {
  EVENT
  NOTE
}

// Google Calendar Integration Models

model ExternalAccount {
  id               String              @id @default(cuid())
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  userId           String
  provider         String              // "GOOGLE"
  providerAccountId String            // Google user email or ID
  accessToken      String              // Encrypted
  refreshToken     String?             // Encrypted
  tokenExpiresAt   DateTime?
  scope            String?
  revokedAt        DateTime?

  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  calendars        ExternalCalendar[]
  syncState        ExternalSyncState?
  availabilityBlocks ExternalAvailabilityBlock[]
  eventLinks       ExternalEventLink[]

  @@unique([userId, provider])
  @@index([userId])
}

model ExternalCalendar {
  id                  String          @id @default(cuid())
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  externalAccountId   String
  calendarId          String          // Google Calendar ID
  summary             String          // Calendar name
  primary             Boolean         @default(false)
  selected            Boolean         @default(false)
  backgroundColor     String?
  foregroundColor     String?

  externalAccount     ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@unique([externalAccountId, calendarId])
  @@index([externalAccountId])
}

model ExternalAvailabilityBlock {
  id                  String          @id @default(cuid())
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  userId              String
  externalAccountId   String
  calendarId          String          // Which calendar this busy block is from
  startAt             DateTime
  endAt               DateTime
  source              String          @default("GOOGLE")

  user                User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  externalAccount     ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([userId, startAt])
  @@index([externalAccountId])
}

model ExternalSyncState {
  id                  String          @id @default(cuid())
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  externalAccountId   String          @unique
  lastSyncedAt        DateTime?
  lastSyncError       String?
  syncToken           String?         // For incremental sync
  channelId           String?         // For webhook notifications
  resourceId          String?         // For webhook notifications
  channelExpiration   DateTime?       // For webhook notifications

  externalAccount     ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)
}

model ExternalEventLink {
  id                  String          @id @default(cuid())
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  eventId             String          @unique
  externalAccountId   String
  externalEventId     String          // Google Calendar event ID
  calendarId          String          // Which Google Calendar the event is in
  etag                String?         // For conflict detection
  lastSyncedAt        DateTime?

  event               Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  externalAccount     ExternalAccount @relation(fields: [externalAccountId], references: [id], onDelete: Cascade)

  @@index([externalAccountId])
}
